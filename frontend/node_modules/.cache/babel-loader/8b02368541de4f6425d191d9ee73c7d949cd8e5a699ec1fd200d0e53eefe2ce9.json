{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nexport function autoPtgSizes(ptgSizes, minPtgSizes, maxPtgSizes) {\n  // Static current data\n  let currentTotalPtg = 0;\n  const undefinedIndexes = [];\n  ptgSizes.forEach((size, index) => {\n    if (size === undefined) {\n      undefinedIndexes.push(index);\n    } else {\n      currentTotalPtg += size;\n    }\n  });\n  const restPtg = 1 - currentTotalPtg;\n  const undefinedCount = undefinedIndexes.length;\n  // Fill if exceed\n  if (restPtg < 0) {\n    const scale = 1 / currentTotalPtg;\n    return ptgSizes.map(size => size === undefined ? 0 : size * scale);\n  }\n  // Check if limit exists\n  let sumMin = 0;\n  let sumMax = 0;\n  let limitMin = 0;\n  let limitMax = 1;\n  for (const index of undefinedIndexes) {\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    sumMin += min;\n    sumMax += max;\n    limitMin = Math.max(limitMin, min);\n    limitMax = Math.min(limitMax, max);\n  }\n  // Impossible case, just average fill\n  if (sumMin > 1 && sumMax < 1) {\n    const avg = 1 / undefinedCount;\n    return ptgSizes.map(size => size === undefined ? avg : size);\n  }\n  // Quickly fill if can\n  const restAvg = restPtg / undefinedCount;\n  if (limitMin <= restAvg && restAvg <= limitMax) {\n    return ptgSizes.map(size => size === undefined ? restAvg : size);\n  }\n  // Greedy algorithm\n  const result = _toConsumableArray(ptgSizes);\n  let remain = restPtg - sumMin;\n  for (let i = 0; i < undefinedCount; i += 1) {\n    const index = undefinedIndexes[i];\n    const min = minPtgSizes[index] || 0;\n    const max = maxPtgSizes[index] || 1;\n    result[index] = min;\n    const canAdd = max - min;\n    const add = Math.min(canAdd, remain);\n    result[index] += add;\n    remain -= add;\n  }\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}